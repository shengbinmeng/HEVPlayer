diff -Naur ffmpeg-2.4.4/configure ffmpeg-2.4.4-lentdec/configure
--- ffmpeg-2.4.4/configure  2014-12-01 08:21:56.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/configure  2014-12-17 11:04:37.999839685 +0800
@@ -250,6 +250,7 @@
   --enable-libwebp         enable WebP encoding via libwebp [no]
   --enable-libx264         enable H.264 encoding via x264 [no]
   --enable-libx265         enable HEVC encoding via x265 [no]
+  --enable-liblenthevcdec  enable HEVC decoding via Lentoid HEVC Decoder(Strongene Inc.)[no]
   --enable-libxavs         enable AVS encoding via xavs [no]
   --enable-libxvid         enable Xvid encoding via xvidcore,
                            native MPEG-4/Xvid encoder exists [no]
@@ -1379,6 +1380,7 @@
     libwebp
     libx264
     libx265
+    liblenthevcdec
     libxavs
     libxvid
     libzmq
@@ -2369,6 +2371,9 @@
 libx264_encoder_deps="libx264"
 libx264rgb_encoder_deps="libx264"
 libx265_encoder_deps="libx265"
+liblenthevc_decoder_deps="liblenthevcdec hevc_parser"
+liblenthevchm10_decoder_deps="liblenthevcdec hevc_parser"
+liblenthevchm91_decoder_deps="liblenthevcdec hevc_parser"
 libxavs_encoder_deps="libxavs"
 libxvid_encoder_deps="libxvid"
 libutvideo_decoder_deps="libutvideo"
@@ -4312,6 +4317,7 @@
 
 die_license_disabled nonfree libaacplus
 die_license_disabled nonfree libfaac
+die_license_disabled nonfree liblenthevcdec
 enabled gpl && die_license_disabled_gpl nonfree libfdk_aac
 enabled gpl && die_license_disabled_gpl nonfree openssl
 
@@ -4871,6 +4877,7 @@
 enabled libx265           && require_pkg_config x265 x265.h x265_encoder_encode &&
                              { check_cpp_condition x265.h "X265_BUILD >= 17" ||
                                die "ERROR: libx265 version must be >= 17."; }
+enabled liblenthevcdec    && require liblenthevcdec lenthevcdec.h lenthevcdec_decode_frame -llenthevcdec
 enabled libxavs           && require libxavs xavs.h xavs_encoder_encode -lxavs
 enabled libxvid           && require libxvid xvid.h xvid_global -lxvidcore
 enabled libzmq            && require_pkg_config libzmq zmq.h zmq_ctx_new
diff -Naur ffmpeg-2.4.4/ffmpeg.c ffmpeg-2.4.4-lentdec/ffmpeg.c
--- ffmpeg-2.4.4/ffmpeg.c   2014-12-01 08:21:38.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/ffmpeg.c   2014-12-17 11:02:30.743839954 +0800
@@ -748,10 +748,29 @@
     AVPacket pkt;
     int got_packet = 0;
 
+    InputStream *ist = NULL;
+    if (ost->source_index >= 0) {
+        ist = input_streams[ost->source_index];
+        /* out the timestamp (offset) in the original input file of the first output frame to video state file */
+        if ( ist && AV_NOPTS_VALUE == ost->original_ts_offset ) {
+            InputFile *ifile = input_files[ist->file_index];
+            int64_t ts_offset, pts;
+            ts_offset = -ifile->ts_offset;
+            if ( 0 && AV_NOPTS_VALUE != ifile->ctx->start_time ) // use relative timestamp
+                ts_offset -= ifile->ctx->start_time;
+            pts = av_rescale_q(frame->pkt_pts / ist->ts_scale,
+                ost->st->time_base, AV_TIME_BASE_Q)
+                    + ts_offset;
+            ost->original_ts_offset = pts;
+            av_log(NULL, AV_LOG_INFO, "%s:%d: original_ts_offset=%f\n",
+                s->filename, ost->index, ost->original_ts_offset / (double)AV_TIME_BASE);
+        }
+    }
+   
+
     av_init_packet(&pkt);
     pkt.data = NULL;
     pkt.size = 0;
-
     if (!check_recording_time(ost))
         return;
 
@@ -963,7 +982,30 @@
     av_init_packet(&pkt);
     pkt.data = NULL;
     pkt.size = 0;
-
+    /* record the timestamp (offset) in the original input file of the first output frame to video state file */
+    if ( ist && AV_NOPTS_VALUE == ost->original_ts_offset ) {
+        InputFile *ifile = input_files[ist->file_index];
+        int64_t ts_offset, pts;
+        ts_offset = -ifile->ts_offset;
+        if ( 0 && AV_NOPTS_VALUE != ifile->ctx->start_time ) // use relative timestamp
+            ts_offset -= ifile->ctx->start_time;
+        pts = av_rescale_q(in_picture->pkt_pts / ist->ts_scale,
+                   ost->st->time_base, AV_TIME_BASE_Q)
+            + ts_offset;
+        ost->original_ts_offset = pts;
+        av_log(NULL, AV_LOG_INFO, "%s:%d: original_ts_offset=%f\n",
+           s->filename, ost->index, ost->original_ts_offset / (double)AV_TIME_BASE);
+        if ( vstats_filename ) {
+            if (!vstats_file) {
+                vstats_file = fopen(vstats_filename, "w");
+                if (!vstats_file) {
+                    perror("fopen");
+                    exit_program(1);
+                }
+            }
+            fprintf(vstats_file, "original_ts_offset=%f\n", ost->original_ts_offset / (double)AV_TIME_BASE);
+        }
+    }
     in_picture->pts = ost->sync_opts;
 
 #if 1
@@ -1625,7 +1667,20 @@
     int64_t ist_tb_start_time = av_rescale_q(start_time, AV_TIME_BASE_Q, ist->st->time_base);
     AVPicture pict;
     AVPacket opkt;
-
+    /* out the timestamp (offset) in the original input file of the first output frame to video state file */
+    if ( AV_NOPTS_VALUE == ost->original_ts_offset ) {
+        InputFile *ifile = input_files[ist->file_index];
+        int64_t ts_offset, pts;
+        ts_offset = -ifile->ts_offset;
+        if ( 0 && AV_NOPTS_VALUE != ifile->ctx->start_time ) // use relative timestamp
+            ts_offset -= ifile->ctx->start_time;
+        pts = av_rescale_q(pkt->pts / ist->ts_scale,
+                   ist->st->time_base, AV_TIME_BASE_Q)
+            + ts_offset;
+        ost->original_ts_offset = pts;
+        av_log(NULL, AV_LOG_INFO, "%s:%d: original_ts_offset=%f\n",
+           ifile->ctx->filename, ost->index, ost->original_ts_offset / (double)AV_TIME_BASE);
+     }
     av_init_packet(&opkt);
 
     if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) &&
diff -Naur ffmpeg-2.4.4/ffmpeg.h ffmpeg-2.4.4-lentdec/ffmpeg.h
--- ffmpeg-2.4.4/ffmpeg.h   2014-12-01 08:21:38.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/ffmpeg.h   2014-12-17 11:02:30.739839954 +0800
@@ -381,6 +381,7 @@
     /* pts of the first frame encoded for this stream, used for limiting
      * recording time */
     int64_t first_pts;
+    int64_t original_ts_offset;
     /* dts of the last packet sent to the muxer */
     int64_t last_mux_dts;
     AVBitStreamFilterContext *bitstream_filters;
diff -Naur ffmpeg-2.4.4/ffmpeg_opt.c ffmpeg-2.4.4-lentdec/ffmpeg_opt.c
--- ffmpeg-2.4.4/ffmpeg_opt.c   2014-12-01 08:21:56.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/ffmpeg_opt.c   2014-12-17 11:02:30.739839954 +0800
@@ -1175,6 +1175,7 @@
         input_streams[source_index]->discard = 0;
         input_streams[source_index]->st->discard = input_streams[source_index]->user_set_discard;
     }
+    ost->original_ts_offset = AV_NOPTS_VALUE;
     ost->last_mux_dts = AV_NOPTS_VALUE;
 
     return ost;
diff -Naur ffmpeg-2.4.4/ffplay.c ffmpeg-2.4.4-lentdec/ffplay.c
--- ffmpeg-2.4.4/ffplay.c   2014-12-01 08:21:38.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/ffplay.c   2014-12-17 11:02:30.739839954 +0800
@@ -2782,6 +2782,7 @@
     AVDictionary **opts;
     int orig_nb_streams;
     SDL_mutex *wait_mutex = SDL_CreateMutex();
+    AVCodec * temp_codec = NULL;
 
     memset(st_index, -1, sizeof(st_index));
     is->last_video_stream = is->video_stream = -1;
@@ -2811,7 +2812,14 @@
 
     opts = setup_find_stream_info_opts(ic, codec_opts);
     orig_nb_streams = ic->nb_streams;
-
+    
+    if (ic->streams[AVMEDIA_TYPE_VIDEO] && video_codec_name) {
+        if (strcmp(video_codec_name,"liblenthevc") == 0)
+        {
+            temp_codec = avcodec_find_decoder_by_name(video_codec_name);
+            ic->streams[AVMEDIA_TYPE_VIDEO]->codec->codec = temp_codec;
+        }
+    }
     err = avformat_find_stream_info(ic, opts);
     if (err < 0) {
         av_log(NULL, AV_LOG_WARNING,
diff -Naur ffmpeg-2.4.4/libavcodec/allcodecs.c ffmpeg-2.4.4-lentdec/libavcodec/allcodecs.c
--- ffmpeg-2.4.4/libavcodec/allcodecs.c 2014-12-01 08:21:39.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavcodec/allcodecs.c 2014-12-17 11:13:08.623838607 +0800
@@ -531,6 +531,7 @@
     REGISTER_ENCODER(LIBXVID,           libxvid);
     REGISTER_DECODER(LIBZVBI_TELETEXT,  libzvbi_teletext);
     REGISTER_ENCODER(LIBAACPLUS,        libaacplus);
+    REGISTER_DECODER(LIBLENTHEVC,       liblenthevc);
 
     /* text */
     REGISTER_DECODER(BINTEXT,           bintext);
diff -Naur ffmpeg-2.4.4/libavcodec/liblenthevcdec.c ffmpeg-2.4.4-lentdec/libavcodec/liblenthevcdec.c
--- ffmpeg-2.4.4/libavcodec/liblenthevcdec.c    1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavcodec/liblenthevcdec.c    2014-12-17 11:02:30.699839954 +0800
@@ -0,0 +1,673 @@
+/*
+ * HEVC decoding using the Strongene Lentoid HEVC decoder
+ * Copyright (C) 2013 Strongene Inc.
+ * James.DF <service@strongene.com>
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "../libavutil/common.h"
+#include "../libavutil/imgutils.h"
+#include "../libavutil/avassert.h"
+#include "../libavutil/timestamp.h"
+#include "avcodec.h"
+#include "lenthevcdec.h"
+
+typedef struct LentHEVCDecContext {
+   lenthevcdec_ctx dec;
+   int     threads;
+   int             length_size;
+   uint8_t*        temp_buf;
+   int             temp_buf_size;
+   int     drop_ref;
+   uint8_t*    reframe_buf;
+   int     reframe_buf_size;
+   int     reframe_buf_idx;
+   int     reframe_buf_offset;
+} LentHEVCDecContext;
+
+static const uint8_t start_code[] = {0x00, 0x00, 0x01};
+
+enum hevc_nal_unit_type_e
+{
+   NAL_UNIT_CODED_SLICE_TRAIL_N = 0,   // 0
+   NAL_UNIT_CODED_SLICE_TRAIL_R,   // 1
+
+   NAL_UNIT_CODED_SLICE_TSA_N,     // 2
+   NAL_UNIT_CODED_SLICE_TLA,       // 3   // Current name in the spec: TSA_R
+
+   NAL_UNIT_CODED_SLICE_STSA_N,    // 4
+   NAL_UNIT_CODED_SLICE_STSA_R,    // 5
+
+   NAL_UNIT_CODED_SLICE_RADL_N,    // 6
+   NAL_UNIT_CODED_SLICE_DLP,       // 7 // Current name in the spec: RADL_R
+
+   NAL_UNIT_CODED_SLICE_RASL_N,    // 8
+   NAL_UNIT_CODED_SLICE_TFD,       // 9 // Current name in the spec: RASL_R
+
+   NAL_UNIT_RESERVED_10,
+   NAL_UNIT_RESERVED_11,
+   NAL_UNIT_RESERVED_12,
+   NAL_UNIT_RESERVED_13,
+   NAL_UNIT_RESERVED_14,
+   NAL_UNIT_RESERVED_15,
+
+   NAL_UNIT_CODED_SLICE_BLA,       // 16   // Current name in the spec: BLA_W_LP
+   NAL_UNIT_CODED_SLICE_BLANT,     // 17   // Current name in the spec: BLA_W_DLP
+   NAL_UNIT_CODED_SLICE_BLA_N_LP,  // 18
+   NAL_UNIT_CODED_SLICE_IDR,       // 19  // Current name in the spec: IDR_W_DLP
+   NAL_UNIT_CODED_SLICE_IDR_N_LP,  // 20
+   NAL_UNIT_CODED_SLICE_CRA,       // 21
+   NAL_UNIT_RESERVED_22,
+   NAL_UNIT_RESERVED_23,
+
+   NAL_UNIT_RESERVED_24,
+   NAL_UNIT_RESERVED_25,
+   NAL_UNIT_RESERVED_26,
+   NAL_UNIT_RESERVED_27,
+   NAL_UNIT_RESERVED_28,
+   NAL_UNIT_RESERVED_29,
+   NAL_UNIT_RESERVED_30,
+   NAL_UNIT_RESERVED_31,
+
+   NAL_UNIT_VPS,                   // 32
+   NAL_UNIT_SPS,                   // 33
+   NAL_UNIT_PPS,                   // 34
+   NAL_UNIT_ACCESS_UNIT_DELIMITER, // 35
+   NAL_UNIT_EOS,                   // 36
+   NAL_UNIT_EOB,                   // 37
+   NAL_UNIT_FILLER_DATA,           // 38
+   NAL_UNIT_SEI,                   // 39 Prefix SEI
+   NAL_UNIT_SEI_SUFFIX,            // 40 Suffix SEI
+
+   NAL_UNIT_RESERVED_41,
+   NAL_UNIT_RESERVED_42,
+   NAL_UNIT_RESERVED_43,
+   NAL_UNIT_RESERVED_44,
+   NAL_UNIT_RESERVED_45,
+   NAL_UNIT_RESERVED_46,
+   NAL_UNIT_RESERVED_47,
+   NAL_UNIT_UNSPECIFIED_48,
+   NAL_UNIT_UNSPECIFIED_49,
+   NAL_UNIT_UNSPECIFIED_50,
+   NAL_UNIT_UNSPECIFIED_51,
+   NAL_UNIT_UNSPECIFIED_52,
+   NAL_UNIT_UNSPECIFIED_53,
+   NAL_UNIT_UNSPECIFIED_54,
+   NAL_UNIT_UNSPECIFIED_55,
+   NAL_UNIT_UNSPECIFIED_56,
+   NAL_UNIT_UNSPECIFIED_57,
+   NAL_UNIT_UNSPECIFIED_58,
+   NAL_UNIT_UNSPECIFIED_59,
+   NAL_UNIT_UNSPECIFIED_60,
+   NAL_UNIT_UNSPECIFIED_61,
+   NAL_UNIT_UNSPECIFIED_62,
+   NAL_UNIT_UNSPECIFIED_63,
+   NAL_UNIT_INVALID,
+};
+
+/* read integer from memory with network byte order */
+/* max size is 4, means read 32bit integer */
+static uint32_t mem_read_int(void* addr, size_t size)
+{
+   uint8_t* p = (uint8_t*)addr;
+   uint32_t ret = 0;
+   av_assert0(size <= 4);
+   for ( ; size > 0; size-- ) {
+       ret = (ret << 8) | *p++;
+   }
+   return ret;
+}
+
+/* convert length prefix to start code */
+/* if dst is NULL, convertion operate in src buffer, otherwise convert to dst buffer */
+/* return destination data length, or negative if failed */
+static int length_prefix_to_start_code(size_t length_size,
+                      void* src, size_t src_size,
+                      void* dst, size_t dst_size)
+{
+   uint8_t *s = (uint8_t*)src, *s_end = s + src_size;
+   uint8_t *d_start = (uint8_t*)dst, *d = d_start, *d_end = d + dst_size;
+   uint32_t length;
+   if ( NULL == dst ) {/* inplace operation */
+       if ( length_size < sizeof(start_code) ) {
+           /* inplace operation is impossible, */
+           /* length size less than start code size */
+           return -1;
+       }
+       d_start = d = s;
+       d_end = s_end;
+   }
+   while ( (s + length_size) < s_end ) {
+       if ( (d + sizeof(start_code)) > d_end )
+           return -2;/* dst buffer too small */
+       length = mem_read_int(s, length_size);
+       /* write start code */
+       if ( NULL == dst ) {
+           memset(d, 0, length_size);
+           d += length_size - sizeof(start_code);
+       }
+       memcpy(d, start_code, sizeof(start_code));
+       s += length_size;
+       d += sizeof(start_code);
+       /* write data */
+       if ( (s + length) > s_end )
+           length = s_end - s;
+       if ( (d + length) > d_end )
+           return -2;/* dst buffer too small */
+       if ( NULL != dst ) {
+           memcpy(d, s, length);
+       }
+       s += length;
+       d += length;
+   }
+   return (d - d_start);
+}
+
+static int get_nal(void* bs_buf, size_t bs_len, int *start_ptr, int *len_ptr, enum hevc_nal_unit_type_e *type_ptr)
+{
+   uint8_t *buf;
+   int start, start_next;
+   if ( NULL != start_ptr ) *start_ptr = 0;
+   if ( NULL != len_ptr ) *len_ptr = 0;
+   if ( NULL != type_ptr ) *type_ptr = NAL_UNIT_INVALID;
+   buf = (uint8_t*)bs_buf;
+   // find start code
+   for ( start = 0; start <= (bs_len - sizeof(start_code)); start++ ) {
+       if ( memcmp(buf + start, start_code, sizeof(start_code)) == 0 )
+           break;
+   }
+   if ( start > (bs_len - sizeof(start_code)) )
+       return -1;
+   if ( NULL != start_ptr )
+       *start_ptr = start;
+   if ( NULL != type_ptr ) {
+       if ( bs_len < (start + sizeof(start_code) + 1) )
+           return -2;
+       *type_ptr = (enum hevc_nal_unit_type_e)((buf[start + sizeof(start_code)] >> 1) & 0x3f);
+   }
+   // find next start code
+   if ( NULL != len_ptr ) {
+       for ( start_next = start + sizeof(start_code); start_next <= (bs_len - sizeof(start_code)); start_next++ ) {
+           if ( memcmp(buf + start_next, start_code, sizeof(start_code)) == 0 )
+               break;
+       }
+       if ( start_next > (bs_len - sizeof(start_code)) )
+           start_next = bs_len;
+       *len_ptr = start_next - start;
+   }
+   return 0;
+}
+
+/* input bitstream and output one frame */
+/* return -1 if error occured; */
+/* return  0 if no frame output; */
+/* return  1 if one frame output and no more frame can be output; */
+/* return  2 if one frame output and have more frame can be output(not implement) */
+#define FRAME_FLAG_KEY     0x01/* [output flag] return frame is a key-frame */
+#define FRAME_FLAG_NOREF   0x02/* [output flag] return frame is a non-reference frame */
+#define FRAME_FLAG_FLUSH   0x80/* [input flag] force to flush the remain data if next AU delimiter not found */
+static int reframe(AVCodecContext *avctx, void* data, int size,
+          uint8_t** frame, int* frame_size, int* frame_flags)
+{
+   uint8_t *pos;
+   int expect_buf_size, remain, is_no_ref, is_key_frame;
+   int nal_start, nal_len, flush;
+   enum hevc_nal_unit_type_e nal_type;
+   LentHEVCDecContext *lent;
+   if ( size < 0 )
+       return -1;
+   lent = (NULL != avctx) ? avctx->priv_data : NULL;
+   if ( NULL == lent )
+       return -1;
+   flush = (*frame_flags & FRAME_FLAG_FLUSH) != 0;
+   *frame = NULL;
+   *frame_size = 0;
+   *frame_flags = 0;
+   /* reframe mode decide */
+   if ( 0 == lent->reframe_buf_size ) {
+       if ( 0 == size )/* flush in uncertain status */
+           return 0;
+       if ( get_nal(data, size, NULL, NULL, &nal_type) >= 0 &&
+            NAL_UNIT_ACCESS_UNIT_DELIMITER == nal_type ) {
+           lent->reframe_buf = av_malloc(size);
+           if ( NULL == lent->reframe_buf )
+               return -1;
+           lent->reframe_buf_size = size;
+       } else {
+           lent->reframe_buf_size = -1;/* AU delimiter not found, use bypass mode */
+       }
+   }
+   /* bypass mode */
+   if ( lent->reframe_buf_size < 0 ) {
+       *frame = (uint8_t*)data;
+       *frame_size = size;
+   }
+   /* rebuild mode */
+   else {
+       /* remove prevoius frame */
+       av_assert0(lent->reframe_buf_idx >= lent->reframe_buf_offset);
+       if ( lent->reframe_buf_offset > 0 ) {
+           remain = lent->reframe_buf_idx - lent->reframe_buf_offset;
+           if ( remain > 0 )
+               memmove(lent->reframe_buf, lent->reframe_buf + lent->reframe_buf_offset, remain);
+           lent->reframe_buf_idx = remain;
+           lent->reframe_buf_offset = 0;
+       }
+       /* copy packet to reframe buffer */
+       expect_buf_size = lent->reframe_buf_idx + size;
+       if ( expect_buf_size > lent->reframe_buf_size ) {
+           lent->reframe_buf = av_realloc_f(lent->reframe_buf, expect_buf_size, 1);
+           if ( NULL == lent->reframe_buf ) {
+               lent->reframe_buf_size = 0;
+               return -1;
+           }
+           lent->reframe_buf_size = expect_buf_size;
+       }
+       if ( size > 0 )
+           memcpy(lent->reframe_buf + lent->reframe_buf_idx, data, size);
+       lent->reframe_buf_idx += size;
+       /* find first AU delimiter */
+       pos = lent->reframe_buf;
+       remain = lent->reframe_buf_idx;
+       if ( get_nal(pos, remain, &nal_start, &nal_len, &nal_type) < 0 )
+           return 0;
+       *frame = pos;
+       if ( NAL_UNIT_ACCESS_UNIT_DELIMITER == nal_type )
+           *frame  = pos + nal_start;
+       pos    += nal_start + nal_len;
+       remain -= nal_start + nal_len;
+       /* find next AU delimiter */
+       while ( remain > 0 && get_nal(pos, remain, &nal_start, &nal_len, &nal_type) >= 0 ) {
+           if ( NAL_UNIT_ACCESS_UNIT_DELIMITER == nal_type )
+               break;
+           pos    += nal_start + nal_len;
+           remain -= nal_start + nal_len;
+       }
+       if ( !(remain > 0 && NAL_UNIT_ACCESS_UNIT_DELIMITER == nal_type) ) {/* next AU delimiter not found */
+           if ( flush ) {
+               pos += remain;/* flush remain data */
+               remain = 0;
+           } else {
+               return 0;/* wait more data */
+           }
+       }
+       *frame_size = pos - *frame;
+       lent->reframe_buf_offset = pos - lent->reframe_buf;
+   }
+   /* find frame flags */
+   pos = *frame;
+   remain = *frame_size;
+   is_no_ref = 1;
+   is_key_frame = 0;
+   while ( remain > 0 && get_nal(pos, remain, &nal_start, &nal_len, &nal_type) >= 0 ) {
+     if ( NAL_UNIT_CODED_SLICE_TRAIL_N != nal_type &&
+          NAL_UNIT_ACCESS_UNIT_DELIMITER != nal_type &&
+          NAL_UNIT_SEI != nal_type &&
+          NAL_UNIT_SEI_SUFFIX != nal_type )
+       is_no_ref = 0;
+     if ( NAL_UNIT_CODED_SLICE_BLA      == nal_type ||
+          NAL_UNIT_CODED_SLICE_BLANT    == nal_type ||
+          NAL_UNIT_CODED_SLICE_BLA_N_LP == nal_type ||
+          NAL_UNIT_CODED_SLICE_IDR      == nal_type ||
+          NAL_UNIT_CODED_SLICE_IDR_N_LP == nal_type ||
+          NAL_UNIT_CODED_SLICE_CRA      == nal_type ) {
+       is_key_frame = 1;
+     }
+     pos    += nal_start + nal_len;
+     remain -= nal_start + nal_len;
+   }
+   *frame_flags = (is_no_ref ? FRAME_FLAG_NOREF : 0) | (is_key_frame ? FRAME_FLAG_KEY : 0);
+   return (*frame_size > 0 ) ? 1 : 0;
+}
+
+/* data contain "avcC" box data */
+static int lent_hevc_dec_decode_extradata(AVCodecContext *avctx,
+                     void* data, int size)
+{
+   int bytes_used, got_frame, w, h, stride[3];
+   int64_t pts;
+   uint8_t* pixels[3];
+   uint8_t *p, *p_end, *seq_hdr_buf;
+   int seq_hdr_buf_size, seq_hdr_len, sps_count, pps_count, nal_len, i;
+   LentHEVCDecContext *lent = (NULL != avctx) ? avctx->priv_data : NULL;
+   lenthevcdec_ctx dec = (NULL != lent) ? lent->dec : NULL;
+
+   if ( NULL == avctx || NULL == dec )
+       return AVERROR_EXTERNAL;
+   if ( size < 3 )
+       return AVERROR_INVALIDDATA;
+
+   p = (uint8_t*)data;
+   p_end = p + size;
+   seq_hdr_buf = NULL;
+   seq_hdr_len = 0;
+
+   /* for NALUs */
+   if ( p[0] == 0 && p[1] == 0 && (p[2] == 1 || (size >= 4 && p[2] == 0 && p[3] == 1)) ) {
+       seq_hdr_buf = p;
+       seq_hdr_len = size;
+   }
+   /* for AVCDecoderConfigurationRecord in AVCc box */
+   else if (size >= 7 &&
+                (1 == p[0]) && // configurationVersion
+                (p[4]&0xFC) == 0xFC && // Reserved
+                (p[5]&0xE0) == 0xE0 ) { // Reserved
+       
+       if ( size < 7 )
+           return AVERROR_INVALIDDATA;
+       seq_hdr_buf_size = size * 2;
+       seq_hdr_buf = (uint8_t*)av_malloc(seq_hdr_buf_size);
+       if ( NULL == seq_hdr_buf )
+           return AVERROR_EXTERNAL;
+       seq_hdr_len = 0;
+
+       /* parse length size */
+       lent->length_size = (p[4] & 0x03) + 1;
+   
+       /* extract SPS from avcC */
+       sps_count = p[5] & 0x1F;
+       p += 6;
+       for ( i = 0; i < sps_count && (p + 2) < p_end; i++ ) {
+           /* get nal length */
+           nal_len = ((int)p[0] << 8) | ((int)p[1]);
+           if ( (p + nal_len) > p_end ||
+                (seq_hdr_len + sizeof(start_code) + nal_len) > seq_hdr_buf_size )
+               break;/* buffer overflow */
+           /* write nal start code */
+           memcpy(seq_hdr_buf + seq_hdr_len, start_code, sizeof(start_code));
+           p += 2;
+           seq_hdr_len += sizeof(start_code);
+           /* write nal payload */
+           memcpy(seq_hdr_buf + seq_hdr_len, p, nal_len);
+           p += nal_len;
+           seq_hdr_len += nal_len;
+       }
+       if ( i < sps_count ) {
+           av_freep(&seq_hdr_buf);
+           return AVERROR_INVALIDDATA;
+       }
+   
+       /* extract PPS from avcC */
+       pps_count = *p++;
+       for ( i = 0; i < pps_count && (p + 2) < p_end; i++ ) {
+           /* get nal length */
+           nal_len = ((int)p[0] << 8) | ((int)p[1]);
+           if ( (p + nal_len) > p_end ||
+                (seq_hdr_len + sizeof(start_code) + nal_len) > seq_hdr_buf_size )
+               break;/* buffer overflow */
+           /* write nal start code */
+           memcpy(seq_hdr_buf + seq_hdr_len, start_code, sizeof(start_code));
+           p += 2;
+           seq_hdr_len += sizeof(start_code);
+           /* write nal payload */
+           memcpy(seq_hdr_buf + seq_hdr_len, p, nal_len);
+           p += nal_len;
+           seq_hdr_len += nal_len;
+       }
+       if ( i < pps_count ) {
+           av_freep(&seq_hdr_buf);
+           return AVERROR_INVALIDDATA;
+       }
+   }
+   else if(     size >= 18 &&
+                (0 == p[0] || 1 == p[0]) && // configurationVersion
+                (p[13]&0xF0) == 0xF0 && // Reserved
+                (p[15]&0xFC) == 0xFC && // Reserved
+                (p[16]&0xFC) == 0xFC && // Reserved
+                (p[17]&0xF8) == 0xF8 && // Reserved
+                (p[18]&0xF8) == 0xF8 ) {
+                    
+       lent->length_size = (p[21] & 0x03) + 1;
+       seq_hdr_buf_size = size * 2;
+       seq_hdr_buf = (uint8_t*)av_malloc(seq_hdr_buf_size);
+       if ( NULL == seq_hdr_buf )
+           return AVERROR_EXTERNAL;
+       seq_hdr_len = 0;
+       p += 22;
+       int type_count = *p++;
+       while ( (p+3) < p_end && type_count-- > 0 ) {
+           int completeness = p[0] & 0x80;
+           if ( p[0] & 0x40 ) {
+               break;
+           }
+           int parameter_type = *p++ & 0x3F;
+           int nalu_count = p[0] * 256 + p[1];
+           p += 2;
+           while ( (p+2) < p_end && nalu_count-- > 0 ) {
+               int len = p[0] * 256 + p[1];
+               p += 2;
+               if ( (p + len) <= p_end ) {
+                   /* write nal start code */
+                   memcpy(seq_hdr_buf + seq_hdr_len, start_code, sizeof(start_code));
+                   seq_hdr_len += sizeof(start_code);
+                   memcpy(seq_hdr_buf + seq_hdr_len , p, len);
+                   seq_hdr_len += len;
+               }
+               p += len;
+           }
+       }
+   } else {
+       av_assert1( 0 );
+       av_log(avctx, AV_LOG_WARNING,
+              "extra data type unknown! [%02x %02x %02x ...]\n",
+              p[0], p[1], p[2]);
+   }
+   if ( seq_hdr_len <= 0 )
+       return 0;
+   
+   /* decode sequence header */
+   w = h = 0;
+   bytes_used = lenthevcdec_decode_frame(dec, seq_hdr_buf, seq_hdr_len, 0,
+                         &got_frame, &w, &h, stride,
+                         (void**)pixels, &pts);
+   if ( seq_hdr_buf != (uint8_t*)data )
+       av_freep(&seq_hdr_buf);
+   if ( bytes_used < 0 && 0 == w && 0 == h ) {
+       /* liblenthevcdec expect whole frame input one time, in this case, we */
+       /*  only sequence header, no any slice data, so call will be failed, */
+       /*  but width and height maybe update right */
+       return AVERROR_INVALIDDATA;
+   }
+   if ( 0 != w && 0 != h && (w != avctx->width || h != avctx->height) ) {
+       av_log(avctx,AV_LOG_INFO, "dimension change! %dx%d -> %dx%d\n",
+              avctx->width, avctx->height, w, h);
+       if ( av_image_check_size(w, h, 0, avctx) )
+           return AVERROR_INVALIDDATA;
+       avcodec_set_dimensions(avctx, w, h);
+   }
+   return 0;
+}
+
+
+static av_cold int lent_hevc_dec_init(AVCodecContext *avctx)
+{
+   int32_t compatibility, ret;
+   LentHEVCDecContext *lent = avctx->priv_data;
+   compatibility = INT32_MAX; /* use last version */
+   lent->length_size = 0; /* means user start code, we donot need convert */
+   lent->temp_buf = NULL;
+   lent->temp_buf_size = 0;
+   lent->reframe_buf = NULL;
+   lent->reframe_buf_size = 0;
+   lent->reframe_buf_idx = 0;
+   lent->reframe_buf_offset = 0;
+   lent->threads = (avctx->thread_count < 8) ? avctx->thread_count : 8;
+   if ( lent->threads == 0 ) { /* Auto threads */
+       int cores = av_cpu_count();
+       lent->threads = (cores > 1) ? ((cores < 4) ? (cores * 2) : 8) : 1;
+       av_log(avctx,AV_LOG_INFO, "%d cpu core(s) detected, use %d thread(s)\n", cores, lent->threads);
+   }
+   lent->dec = lenthevcdec_create(lent->threads, compatibility, NULL);
+   if ( NULL == lent->dec )
+       return AVERROR_EXTERNAL;
+   if ( avctx->extradata_size > 0 && avctx->extradata ) {
+       ret = lent_hevc_dec_decode_extradata(avctx, avctx->extradata,
+                            avctx->extradata_size);
+       if ( ret < 0 ) {
+           lenthevcdec_destroy(lent->dec);
+           return ret;
+       }
+   }
+   avctx->pix_fmt = PIX_FMT_YUV420P;
+   return 0;
+}
+
+static av_cold int lent_hevc_dec_close(AVCodecContext *avctx)
+{
+   LentHEVCDecContext *lent = avctx->priv_data;
+   if ( NULL != lent->dec ) {
+       lenthevcdec_destroy(lent->dec);
+       lent->dec = NULL;
+       if ( NULL != lent->temp_buf )
+           av_freep(&lent->temp_buf);
+       if ( NULL != lent->reframe_buf )
+           av_freep(&lent->reframe_buf);
+   }
+   return 0;
+ }
+
+static int lent_hevc_dec_decode(AVCodecContext *avctx, void *data,
+               int *got_frame, AVPacket *avpkt)
+{
+   LentHEVCDecContext *lent = avctx->priv_data;
+   AVFrame *pict = data;
+   uint8_t *buf = avpkt->data;
+   int buf_size = avpkt->size;
+   uint8_t *frame = NULL;
+   int frame_size = 0, frame_flags = 0;
+   int ret, frame_flush, bytes_used, w, h;
+   int64_t pts;
+   if ( NULL == lent->dec )
+       return -1;
+   *got_frame = 0;
+   /* rebuild frame from input bitstream */
+   /* first, we flush the inner reframe buffer for big-packet that contain multi-frame in on packet */
+   frame_flags = 0;
+   ret = reframe(avctx, NULL, 0, &frame, &frame_size, &frame_flags);
+   if ( ret > 0 ) {
+       /* flush inner reframe buffer */
+       frame_flush = 1;
+   } else {
+       frame_flush = 0;
+       /* convert length prefix to start code */
+       if ( buf_size > 0 && 0 != lent->length_size ) {
+           int len_size = lent->length_size;
+           av_assert0(len_size <= 4);
+           if ( len_size < 3 ) { /* we must expan data buffer */
+               int expand_size = buf_size * 3;
+               if ( NULL == lent->temp_buf || lent->temp_buf_size < expand_size ) {
+                   lent->temp_buf = av_realloc_f(lent->temp_buf, expand_size, 1);
+                   if ( NULL == lent->temp_buf ) {
+                       lent->temp_buf_size = 0;
+                       return -1;
+                   }
+                   lent->temp_buf_size = expand_size;
+               }
+               buf_size = length_prefix_to_start_code(len_size, buf, buf_size,
+                                      lent->temp_buf, lent->temp_buf_size);
+               if ( buf_size < 0 )
+                   return -1;
+               buf = lent->temp_buf;
+           } else { /* replace length prefix with start code */
+               buf_size = length_prefix_to_start_code(len_size, buf, buf_size, NULL, 0);
+               if ( buf_size < 0 )
+                   return -1;
+           }
+       }
+       /* second, we use input packet data to rebuild frame */
+       if ( 0 == buf_size )/* ffmpeg flush decoder */
+           frame_flags = FRAME_FLAG_FLUSH;/* if next AU delimiter not found, flush remain data */
+       ret = reframe(avctx, buf, buf_size, &frame, &frame_size, &frame_flags);
+       if ( ret < 0 )
+           return ret;
+       if ( 0 == ret && NULL != buf ) {
+           /* no frame output, wait more data intput */
+           return avpkt->size;
+       }
+   }
+
+   /* discard */
+   if ( buf_size > 0 && (avctx->skip_frame >= AVDISCARD_NONREF || lent->drop_ref) ) {
+       int is_no_ref = (frame_flags & FRAME_FLAG_NOREF) != 0;
+       int is_key_frame = (frame_flags & FRAME_FLAG_KEY) != 0;
+       if ( lent->drop_ref && !is_key_frame ) {
+           av_log(avctx, AV_LOG_VERBOSE, "skip nonkey frame because reference frame droped. dts:%s pts:%s\n",
+                  av_ts2str(avpkt->dts), av_ts2str(avpkt->pts));
+           return avpkt->size;
+       }
+       if ( is_key_frame )
+           lent->drop_ref = 0;
+       if ( avctx->skip_frame >= AVDISCARD_NONREF && is_no_ref ) {
+           av_log(avctx, AV_LOG_VERBOSE, "skip no reference frame. dts:%s pts:%s\n",
+                  av_ts2str(avpkt->dts), av_ts2str(avpkt->pts));
+           return avpkt->size;
+       }
+       if ( (avctx->skip_frame == AVDISCARD_NONKEY && !is_key_frame) ||
+            (avctx->skip_frame == AVDISCARD_ALL) ) {
+           lent->drop_ref = 1;
+           av_log(avctx, AV_LOG_VERBOSE, "skip %s frame. dts:%s pts:%s\n",
+                  is_key_frame ? "key" : "reference", av_ts2str(avpkt->dts), av_ts2str(avpkt->pts));
+           return avpkt->size;
+       }
+   }
+   /* decode one frame */
+   bytes_used = lenthevcdec_decode_frame(lent->dec, frame, frame_size, avpkt->pts,
+                         got_frame, &w, &h, pict->linesize,
+                         (void**) pict->data, &pts);
+   av_log(avctx, AV_LOG_DEBUG, "decode frame: %d bytes, used %d, got_frame %d, w %d, h %d, pts %s\n",
+          frame_size, bytes_used, *got_frame, w, h, av_ts2str((*got_frame<=0)?AV_NOPTS_VALUE:pts));
+   if ( bytes_used < 0 )
+       return AVERROR_INVALIDDATA;
+   if ( *got_frame > 0 && 0 != w && 0 != h && (w != avctx->width || h != avctx->height) ) {
+       av_log(avctx,AV_LOG_INFO, "dimension change! %dx%d -> %dx%d\n",
+              avctx->width, avctx->height, w, h);
+       if ( av_image_check_size(w, h, 0, avctx) )
+           return AVERROR_INVALIDDATA;
+       avcodec_set_dimensions(avctx, w, h);
+   }
+   if ( 0 ==  bytes_used ) {
+       bytes_used = 1; /* avoid infinite loops */
+   }
+   if ( *got_frame <= 0 ) {
+       av_log(avctx, AV_LOG_VERBOSE, "no frame output\n");
+       return /*bytes_used*/avpkt->size;
+   }
+   pict->data[3] = NULL;
+   pict->linesize[3] = 0;
+   pict->pict_type = AV_PICTURE_TYPE_I;
+   pict->key_frame = 1;
+   pict->pts = pts;
+   pict->pkt_pts = pts;
+   av_log(avctx, AV_LOG_DEBUG, "got frame, pts = %s\n", av_ts2str(pict->pts));
+   return frame_flush ? 0 : (/* bytes_used */avpkt->size);
+}
+
+static void lent_hevc_dec_flush(AVCodecContext *avctx)
+{
+   LentHEVCDecContext *lent = avctx->priv_data;
+   if ( NULL == lent->dec )
+       return;
+   /* set discontinuity flash */
+   lent->drop_ref = 1;
+   /* clear reframe buffer */
+   lent->reframe_buf_idx = 0;
+   lent->reframe_buf_offset = 0;
+}
+
+
+AVCodec ff_liblenthevc_decoder = {
+   .name       = "liblenthevc",
+   .type       = AVMEDIA_TYPE_VIDEO,
+   .id     = AV_CODEC_ID_HEVC,
+   .priv_data_size = sizeof(LentHEVCDecContext),
+   .init       = lent_hevc_dec_init,
+   .close      = lent_hevc_dec_close,
+   .decode     = lent_hevc_dec_decode,
+   .flush      = lent_hevc_dec_flush,
+   .capabilities   = CODEC_CAP_DELAY | CODEC_CAP_AUTO_THREADS,
+   .long_name  = NULL_IF_CONFIG_SMALL("Strongene Lentoid HEVC"),
+   .pix_fmts   = (const enum PixelFormat[]){ PIX_FMT_YUV420P, PIX_FMT_NONE },
+};
diff -Naur ffmpeg-2.4.4/libavcodec/Makefile ffmpeg-2.4.4-lentdec/libavcodec/Makefile
--- ffmpeg-2.4.4/libavcodec/Makefile    2014-12-01 08:21:38.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavcodec/Makefile    2014-12-17 11:17:58.407837995 +0800
@@ -764,6 +764,7 @@
 OBJS-$(CONFIG_LIBX265_ENCODER)            += libx265.o
 OBJS-$(CONFIG_LIBXAVS_ENCODER)            += libxavs.o
 OBJS-$(CONFIG_LIBXVID_ENCODER)            += libxvid.o
+OBJS-$(CONFIG_LIBLENTHEVC_DECODER)        += liblenthevcdec.o
 OBJS-$(CONFIG_LIBZVBI_TELETEXT_DECODER)   += libzvbi-teletextdec.o
 
 # parsers
diff -Naur ffmpeg-2.4.4/libavcodec/utils.c ffmpeg-2.4.4-lentdec/libavcodec/utils.c
--- ffmpeg-2.4.4/libavcodec/utils.c 2014-12-01 08:21:56.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavcodec/utils.c 2014-12-17 11:02:30.707839954 +0800
@@ -2829,6 +2829,8 @@
 
 AVCodec *avcodec_find_decoder(enum AVCodecID id)
 {
+    //if(id == AV_CODEC_ID_HEVC)
+    //    return avcodec_find_decoder_by_name("liblenthevc");
     return find_encdec(id, 0);
 }
 
diff -Naur ffmpeg-2.4.4/libavformat/flvdec.c ffmpeg-2.4.4-lentdec/libavformat/flvdec.c
--- ffmpeg-2.4.4/libavformat/flvdec.c   2014-12-01 08:21:47.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavformat/flvdec.c   2014-12-17 11:02:30.683839954 +0800
@@ -231,6 +231,10 @@
         return vcodec->codec_id == AV_CODEC_ID_VP6A;
     case FLV_CODECID_H264:
         return vcodec->codec_id == AV_CODEC_ID_H264;
+    case FLV_CODECID_HEVC_HM91:/* HEVC of Strongene */
+    case FLV_CODECID_HEVC_HM10:/* HEVC of Strongene */
+    case FLV_CODECID_HEVC:/* HEVC of Strongene */
+        return vcodec->codec_id == AV_CODEC_ID_HEVC;
     default:
         return vcodec->codec_tag == flv_codecid;
     }
@@ -275,6 +279,11 @@
     case FLV_CODECID_MPEG4:
         vcodec->codec_id = AV_CODEC_ID_MPEG4;
         return 3;
+    case FLV_CODECID_HEVC_HM91:/* HEVC of Strongene */
+    case FLV_CODECID_HEVC_HM10:/* HEVC of Strongene */
+    case FLV_CODECID_HEVC:
+        vcodec->codec_id = AV_CODEC_ID_HEVC;
+        return 3; // same as H.264
     default:
         avpriv_request_sample(s, "Video codec (%x)", flv_codecid);
         vcodec->codec_tag = flv_codecid;
@@ -939,10 +948,12 @@
 
     if (st->codec->codec_id == AV_CODEC_ID_AAC ||
         st->codec->codec_id == AV_CODEC_ID_H264 ||
-        st->codec->codec_id == AV_CODEC_ID_MPEG4) {
+        st->codec->codec_id == AV_CODEC_ID_MPEG4 ||
+        st->codec->codec_id == AV_CODEC_ID_HEVC) {
         int type = avio_r8(s->pb);
         size--;
-        if (st->codec->codec_id == AV_CODEC_ID_H264 || st->codec->codec_id == AV_CODEC_ID_MPEG4) {
+        if (st->codec->codec_id == AV_CODEC_ID_H264 || st->codec->codec_id == AV_CODEC_ID_MPEG4 ||
+            st->codec->codec_id == AV_CODEC_ID_HEVC) {
             // sign extension
             int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000;
             pts = dts + cts;
diff -Naur ffmpeg-2.4.4/libavformat/flvenc.c ffmpeg-2.4.4-lentdec/libavformat/flvenc.c
--- ffmpeg-2.4.4/libavformat/flvenc.c   2014-12-18 17:37:24.895607388 +0800
+++ ffmpeg-2.4.4-lentdec/libavformat/flvenc.c   2014-12-17 11:02:30.687839954 +0800
@@ -40,6 +40,7 @@
     { AV_CODEC_ID_VP6,      FLV_CODECID_VP6 },
     { AV_CODEC_ID_VP6A,     FLV_CODECID_VP6A },
     { AV_CODEC_ID_H264,     FLV_CODECID_H264 },
+    { AV_CODEC_ID_HEVC,     FLV_CODECID_HEVC },
     { AV_CODEC_ID_NONE,     0 }
 };
 
@@ -179,6 +180,19 @@
     avio_wb32(pb, 16);              /* Size of FLV tag */
 }
 
+static void put_hevc_eos_tag(int codec_id, AVIOContext *pb, unsigned ts)
+{
+    avio_w8(pb, FLV_TAG_TYPE_VIDEO);
+    avio_wb24(pb, 5);                   /* Tag Data Size */
+    avio_wb24(pb, ts);                  /* lower 24 bits of timestamp in ms */
+    avio_w8(pb, (ts >> 24) & 0x7F);     /* MSB of ts in ms */
+    avio_wb24(pb, 0);                   /* StreamId = 0 */
+    avio_w8(pb, 16 | (codec_id & 0x0F));/* ub[4] FrameType = 1, ub[4] CodecId = 7 */
+    avio_w8(pb, 2);                     /* HEVC end of sequence */
+    avio_wb24(pb, 0);                   /* Always 0 for AVC EOS. */
+    avio_wb32(pb, 16);                  /* Size of FLV tag */
+}
+
 static void put_amf_double(AVIOContext *pb, double d)
 {
     avio_w8(pb, AMF_DATA_TYPE_NUMBER);
@@ -191,12 +205,75 @@
     avio_w8(pb, !!b);
 }
 
+static int strongene_write_hevc_avcc(AVIOContext *pb, const uint8_t *data, int len)
+{
+    if (len > 6) {
+        /* check for h264 start code */
+        if (AV_RB32(data) == 0x00000001 ||
+            AV_RB24(data) == 0x000001) {
+            uint8_t *buf=NULL, *end, *start;
+            uint32_t vps_size=0, sps_size=0, pps_size=0;
+            uint8_t *vps=0, *sps=0, *pps=0;
+
+            int ret = ff_avc_parse_nal_units_buf(data, &buf, &len);
+            if (ret < 0)
+                return ret;
+            start = buf;
+            end = buf + len;
+
+            /* look for sps and pps */
+            while (end - buf > 4) {
+                uint32_t size;
+                uint8_t nal_type;
+                size = FFMIN(AV_RB32(buf), end - buf - 4);
+                buf += 4;
+                nal_type = (buf[0] & 0x7e) >> 1;
+
+                if (nal_type == 32) { /* VPS */
+                    vps = buf;
+                    vps_size = size;
+                } else if (nal_type == 33) { /* SPS */
+                    sps = buf;
+                    sps_size = size;
+                } else if (nal_type == 34) { /* PPS */
+                    pps = buf;
+                    pps_size = size;
+                }
+
+                buf += size;
+            }
+ 
+            if (!vps || !sps || !pps || vps_size > UINT16_MAX || sps_size > UINT16_MAX || pps_size > UINT16_MAX)
+                return AVERROR_INVALIDDATA;
+
+            avio_w8(pb, 1); /* version */
+            avio_w8(pb, 0); /* profile */
+            avio_w8(pb, 0); /* profile compat */
+            avio_w8(pb, 0); /* level */
+            avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+            avio_w8(pb, 0xe2); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+
+            avio_wb16(pb, vps_size);
+            avio_write(pb, vps, vps_size);
+            avio_wb16(pb, sps_size);
+            avio_write(pb, sps, sps_size);
+            avio_w8(pb, 1); /* number of pps */
+            avio_wb16(pb, pps_size);
+            avio_write(pb, pps, pps_size);
+            av_free(start);
+        } else {
+            avio_write(pb, data, len);
+        }
+    }
+    return 0;
+}
+
 static int flv_write_header(AVFormatContext *s)
 {
     AVIOContext *pb = s->pb;
     FLVContext *flv = s->priv_data;
     AVCodecContext *audio_enc = NULL, *video_enc = NULL, *data_enc = NULL;
-    int i, metadata_count = 0;
+    int i, is_lent, metadata_count = 0;
     double framerate = 0.0;
     int64_t metadata_size_pos, data_size, metadata_count_pos;
     AVDictionaryEntry *tag = NULL;
@@ -300,13 +377,16 @@
     /* first event name as a string */
     avio_w8(pb, AMF_DATA_TYPE_STRING);
     put_amf_string(pb, "onMetaData"); // 12 bytes
-
+    /* use Strongene Lentoid HEVC encoder ? */
+    is_lent = video_enc &&
+        ( video_enc->codec_id == AV_CODEC_ID_HEVC );
     /* mixed array (hash) with size and string/type/data tuples */
     avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);
     metadata_count_pos = avio_tell(pb);
     metadata_count = 4 * !!video_enc +
                      5 * !!audio_enc +
                      1 * !!data_enc  +
+                     2 * !!is_lent +
                      2; // +2 for duration and file size
 
     avio_wb32(pb, metadata_count);
@@ -317,6 +397,18 @@
     // fill in the guessed duration, it'll be corrected later if incorrect
     put_amf_double(pb, s->duration / AV_TIME_BASE);
 
+    // Strongene Lentoid Encoder information
+    if ( is_lent ) {
+        // Format
+        put_amf_string(pb, "Video Encoder");
+        avio_w8(pb, AMF_DATA_TYPE_STRING);
+        put_amf_string(pb, "Strongene Lentoid HEVC/H.265 Encoder");
+        // Format/Info
+        put_amf_string(pb, "Video Encoder Website");
+        avio_w8(pb, AMF_DATA_TYPE_STRING);
+        put_amf_string(pb, "www.strongene.com");
+    }
+
     if (video_enc) {
         put_amf_string(pb, "width");
         put_amf_double(pb, video_enc->width);
@@ -402,7 +494,8 @@
 
     for (i = 0; i < s->nb_streams; i++) {
         AVCodecContext *enc = s->streams[i]->codec;
-        if (enc->codec_id == AV_CODEC_ID_AAC || enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4) {
+        if (enc->codec_id == AV_CODEC_ID_AAC || enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4 ||
+             enc->codec_id == AV_CODEC_ID_HEVC) {
             int64_t pos;
             avio_w8(pb, enc->codec_type == AVMEDIA_TYPE_VIDEO ?
                     FLV_TAG_TYPE_VIDEO : FLV_TAG_TYPE_AUDIO);
@@ -419,7 +512,11 @@
                 avio_w8(pb, enc->codec_tag | FLV_FRAME_KEY); // flags
                 avio_w8(pb, 0); // AVC sequence header
                 avio_wb24(pb, 0); // composition time
-                ff_isom_write_avcc(pb, enc->extradata, enc->extradata_size);
+                if (enc->codec_id == AV_CODEC_ID_HEVC) {
+                    strongene_write_hevc_avcc(pb, enc->extradata, enc->extradata_size);
+                } else {
+                    ff_isom_write_avcc(pb, enc->extradata, enc->extradata_size);
+                }
             }
             data_size = avio_tell(pb) - pos;
             avio_seek(pb, -data_size - 10, SEEK_CUR);
@@ -447,6 +544,10 @@
         if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
                 (enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4))
             put_avc_eos_tag(pb, sc->last_ts);
+        if ( enc->codec_id == AV_CODEC_ID_HEVC ) {
+            int flv_codec_id = FLV_CODECID_HEVC;
+            put_hevc_eos_tag(flv_codec_id, pb, sc->last_ts);
+        }
     }
 
     file_size = avio_tell(pb);
@@ -479,7 +580,8 @@
     if (enc->codec_id == AV_CODEC_ID_VP6F || enc->codec_id == AV_CODEC_ID_VP6A ||
         enc->codec_id == AV_CODEC_ID_VP6  || enc->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;
-    else if (enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4)
+    else if (enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4 ||
+        enc->codec_id == AV_CODEC_ID_HEVC)
         flags_size = 5;
     else
         flags_size = 1;
@@ -587,7 +689,8 @@
                              (FFALIGN(enc->height, 16) - enc->height));
         } else if (enc->codec_id == AV_CODEC_ID_AAC)
             avio_w8(pb, 1); // AAC raw
-        else if (enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4) {
+        else if (enc->codec_id == AV_CODEC_ID_H264 || enc->codec_id == AV_CODEC_ID_MPEG4 ||
+            enc->codec_id == AV_CODEC_ID_HEVC) {
             avio_w8(pb, 1); // AVC NALU
             avio_wb24(pb, pkt->pts - pkt->dts);
         }
diff -Naur ffmpeg-2.4.4/libavformat/flv.h ffmpeg-2.4.4-lentdec/libavformat/flv.h
--- ffmpeg-2.4.4/libavformat/flv.h  2014-12-01 08:21:47.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavformat/flv.h  2014-12-17 11:02:30.687839954 +0800
@@ -109,6 +109,9 @@
     FLV_CODECID_H264    = 7,
     FLV_CODECID_REALH263= 8,
     FLV_CODECID_MPEG4   = 9,
+    FLV_CODECID_HEVC_HM91=12,
+    FLV_CODECID_HEVC_HM10=13,
+    FLV_CODECID_HEVC    =14,
 };
 
 enum {
diff -Naur ffmpeg-2.4.4/libavformat/mpegtsenc.c ffmpeg-2.4.4-lentdec/libavformat/mpegtsenc.c
--- ffmpeg-2.4.4/libavformat/mpegtsenc.c    2014-12-01 08:21:47.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavformat/mpegtsenc.c    2014-12-17 11:02:30.683839954 +0800
@@ -1275,6 +1275,39 @@
             buf     = data;
             size    = pkt->size + 6;
         }
+    } else if (st->codec->codec_id == AV_CODEC_ID_HEVC ) {
+        const uint8_t *p = buf, *buf_end = p+size;
+        uint32_t state = -1, nal_type, first_slice_in_pic = 0;
+
+        if (pkt->size < 5 || (AV_RB32(pkt->data) != 0x0000001 && (AV_RB32(pkt->data)&0xFFFFFF00) != 0x00000100)) {
+            if (!st->nb_frames) {
+                av_log(s, AV_LOG_ERROR, "H.265/HEVC bitstream malformed, "
+                       "no startcode found, use the h264_mp4toannexb bitstream filter (-bsf h264_mp4toannexb)\n");
+                return AVERROR(EINVAL);
+            }
+            av_log(s, AV_LOG_WARNING, "H.265/HEVC bitstream error, startcode missing\n");
+        }
+
+        do {
+            p = avpriv_find_start_code(p, buf_end, &state);
+        nal_type = (state & 0x7E) >> 1;
+        if ( (p + 1) < buf_end && nal_type < 21 )
+            first_slice_in_pic = (p[1] & 0x80);
+            av_dlog(s, "nal %d\n", nal_type);
+        } while (p < buf_end && nal_type != 35 && !first_slice_in_pic);
+
+        if (nal_type != 35) { // AUD NAL
+            data = av_malloc(pkt->size+7);
+            if (!data)
+                return AVERROR(ENOMEM);
+            memcpy(data+7, pkt->data, pkt->size);
+            AV_WB32(data, 0x00000001);
+            data[4] = (35 << 1);
+            data[5] = 0x01; // layer_id and temporal_id_plus1
+            data[6] = 0x50; // any slice type (010b) + rbsp stop one bit
+            buf  = data;
+            size = pkt->size+7;
+        }
     } else if (st->codec->codec_id == AV_CODEC_ID_AAC) {
         if (pkt->size < 2) {
             av_log(s, AV_LOG_ERROR, "AAC packet too short\n");
diff -Naur ffmpeg-2.4.4/libavformat/utils.c ffmpeg-2.4.4-lentdec/libavformat/utils.c
--- ffmpeg-2.4.4/libavformat/utils.c    2014-12-01 08:21:56.000000000 +0800
+++ ffmpeg-2.4.4-lentdec/libavformat/utils.c    2014-12-17 11:02:30.687839954 +0800
@@ -40,6 +40,7 @@
 #include "libavcodec/bytestream.h"
 #include "libavcodec/internal.h"
 #include "libavcodec/raw.h"
+#include "libavcodec/avcodec.h"
 
 #include "audiointerleave.h"
 #include "avformat.h"
@@ -460,6 +461,18 @@
         *options = tmp;
     }
     *ps = s;
+    /*
+    if(s->streams[AVMEDIA_TYPE_VIDEO] && s->streams[AVMEDIA_TYPE_VIDEO]->codec)
+    {
+        if(s->streams[AVMEDIA_TYPE_VIDEO]->codec->codec_id == AV_CODEC_ID_HEVC)
+        {
+            {
+                AVCodec* lenthevc_decoder = avcodec_find_decoder_by_name("liblenthevc");
+                s->streams[AVMEDIA_TYPE_VIDEO]->codec->codec = lenthevc_decoder;
+            }
+        }
+    }
+    */
     return 0;
 
 fail:
